# -*- coding: utf-8 -*-
"""ES112_Project_UAV.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AMpluWL_mFz3XQCKEssCVwxeMcVG_rD_
"""

import numpy as np
import pandas as pd

df = pd.read_csv('uav_data.csv')

df.info()

pd.set_option('display.max_columns', None)

df.head()

selected_columns = [
    'Task_Type',
    'Battery_Level',
    'Velocity',
    'Wind_Speed',
    'Temperature',
    'Task_Completion_Time',
    'Task_Success',
    'Coverage_Efficiency',
    'Obstacle_Distance',
    'Communication_Signal_Strength'
]

data = df[selected_columns]

data.head()

def get_column_as_list(data, column_name):
    return data[column_name].tolist()

velocities = get_column_as_list(data, 'Velocity')
battery_level = get_column_as_list(data, 'Battery_Level')
wind_speed = get_column_as_list(data, 'Wind_Speed')
temperature = get_column_as_list(data, 'Temperature')
task_comp_time = get_column_as_list(data, 'Task_Completion_Time')
coverage_efficiency = get_column_as_list(data, 'Coverage_Efficiency')
obstacle_distance = get_column_as_list(data, 'Obstacle_Distance')
signal_strength = get_column_as_list(data, 'Communication_Signal_Strength')

"""#Mean Data"""

def meanvalues(data):
    return sum(data) / len(data)

mean_velocity = meanvalues(velocities)
mean_battery_level = meanvalues(battery_level)
mean_wind_speed = meanvalues(wind_speed)
mean_temperature = meanvalues(temperature)
mean_task_comp_time = meanvalues(task_comp_time)
mean_coverage_efficiency = meanvalues(coverage_efficiency)
mean_obstacle_distance = meanvalues(obstacle_distance)
mean_signal_strength = meanvalues(signal_strength)

print("Velocity - Mean:", meanvalues(velocities))
print("Battery Level - Mean:", meanvalues(battery_level))
print("Wind Speed - Mean:", meanvalues(wind_speed))
print("Temperature - Mean:", meanvalues(temperature))
print("Task Completion Time - Mean:", meanvalues(task_comp_time))
print("Coverage Efficiency - Mean:", meanvalues(coverage_efficiency))
print("Obstacle Distance - Mean:", meanvalues(obstacle_distance))
print("Signal Strength - Mean:", meanvalues(signal_strength))

"""#Variance"""

def variancevalues(data, s=1):
    mu = meanvalues(data)
    return sum((x - mu) ** 2 for x in data) / (len(data)-s)

variance_velocity = variancevalues(velocities)
variance_battery_level = variancevalues(battery_level)
variance_wind_speed = variancevalues(wind_speed)
variance_temperature = variancevalues(temperature)
variance_task_comp_time = variancevalues(task_comp_time)
variance_coverage_efficiency = variancevalues(coverage_efficiency)
variance_obstacle_distance = variancevalues(obstacle_distance)
variance_signal_strength = variancevalues(signal_strength)

print("Velocity - Variance:", variancevalues(velocities))
print("Battery Level - Variance:", variancevalues(battery_level))
print("Wind Speed - Variance:", variancevalues(wind_speed))
print("Temperature - Variance:", variancevalues(temperature))
print("Task Completion Time - Variance:", variancevalues(task_comp_time))
print("Coverage Efficiency - Variance:", variancevalues(coverage_efficiency))
print("Obstacle Distance - Variance:", variancevalues(obstacle_distance))
print("Signal Strength - Variance:", variancevalues(signal_strength))

"""#Frequency Distribution Visualisations

##Categorical Column PieChart - Task_Type
"""

import seaborn as sns
import matplotlib.pyplot as plt

colors = ['thistle', 'powderblue', 'lightcoral', 'teal']
data['Task_Type'].value_counts().plot.pie(autopct='%1.1f%%', colors=colors)
plt.title('Task Type Distribution')
plt.ylabel('')
plt.show()

# Frequency distribution via histogram
sns.histplot(data=data, x='Battery_Level', bins=10, kde=True, color='pink')
plt.title('Battery Level Distribution')
plt.xlabel('Battery Level (%)')
plt.ylabel('Frequency')
plt.show()

velocity_bins = pd.cut(data['Velocity'], bins=10)
print(velocity_bins.value_counts().sort_index())

sns.histplot(data['Velocity'], bins=10, kde=True, color ='pink')
plt.title('Velocity Distribution')
plt.xlabel('Velocity')
plt.ylabel('Frequency')
plt.show()

wind_bins = pd.cut(data['Wind_Speed'], bins=10)
wind_freq = wind_bins.value_counts().sort_index()
print(wind_freq)

wind_freq.plot(kind='line', marker='o', color ='pink')
plt.title('Wind Speed Frequency Distribution')
plt.xlabel('Wind Speed Range')
plt.ylabel('Frequency')
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()

temp_bins = pd.cut(data['Temperature'], bins=10)
print(temp_bins.value_counts().sort_index())

sns.histplot(data['Temperature'], bins=10, kde=False, color ='pink')
plt.title('Temperature Distribution')
plt.xlabel('Temperature')
plt.ylabel('Frequency')
plt.show()

success_counts = data['Task_Success'].value_counts()
print(success_counts)

sns.barplot(x=success_counts.index, y=success_counts.values, color='pink')
plt.title('Task Success vs Failure')
plt.xlabel('Success (1 = Yes, 0 = No)')
plt.ylabel('Count')
plt.show()

eff_bins = pd.cut(data['Coverage_Efficiency'], bins=10)
print(eff_bins.value_counts().sort_index())

sns.histplot(data['Coverage_Efficiency'], bins=10, kde=True, color = 'pink')
plt.title('Coverage Efficiency Distribution')
plt.xlabel('Efficiency')
plt.ylabel('Frequency')
plt.show()

obs_bins = pd.cut(data['Obstacle_Distance'], bins=10)
obs_freq = obs_bins.value_counts().sort_index()
print(obs_freq)

obs_freq.plot(kind='line', marker='o', color = 'pink')
plt.title('Obstacle Distance Frequency Distribution')
plt.xlabel('Distance to Obstacle')
plt.ylabel('Frequency')
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()

comm_bins = pd.cut(data['Communication_Signal_Strength'], bins=10)
print(comm_bins.value_counts().sort_index())

fig, ax = plt.subplots(1, 2, figsize=(12, 5))
sns.histplot(data['Communication_Signal_Strength'], bins=10, kde=False, ax=ax[0], color = 'pink')
ax[0].set_title('Communication Signal Histogram')

sns.boxplot(y=data['Communication_Signal_Strength'], ax=ax[1], color = 'pink')
ax[1].set_title('Communication Signal Boxplot')
plt.tight_layout()
plt.show()

sns.boxplot(x='Task_Type', y='Battery_Level', data=data, color = 'pink')
plt.title('Battery Usage by Task Type')
plt.xticks(rotation=45)
plt.ylabel('Battery Level (%)')
plt.show()

sns.violinplot(x='Task_Type', y='Velocity', data=data, color = 'pink')
plt.title('Velocity Distribution by Task Type')
plt.xticks(rotation=45)
plt.ylabel('Velocity')
plt.show()

sns.boxplot(x='Task_Type', y='Task_Completion_Time', data=data, color = 'pink')
plt.title('Task Completion Time by Task Type')
plt.xticks(rotation=45)
plt.ylabel('Completion Time')
plt.show()

sns.boxplot(x='Task_Success', y='Wind_Speed', data=data, color ='pink')
plt.title('Wind Speed vs Task Success')
plt.xticks([0, 1], ['Failure', 'Success'])
plt.ylabel('Wind Speed')
plt.show()

sns.kdeplot(data=data[data['Task_Success'] == 1], x='Temperature', label='Success', shade=True, color = 'pink')
sns.kdeplot(data=data[data['Task_Success'] == 0], x='Temperature', label='Failure', shade=True, color = 'pink')
plt.title('Temperature Distribution by Task Outcome')
plt.xlabel('Temperature')
plt.legend()
plt.show()

sns.boxplot(x='Task_Success', y='Communication_Signal_Strength', data=data, color = 'pink')
plt.title('Signal Strength vs Task Success')
plt.xticks([0, 1], ['Fail', 'Success'])
plt.ylabel('Communication Signal Strength')
plt.show()

"""#Frequency Distributions"""

bins = [0, 20, 40, 60, 80, 100]

data['Battery_Bin'] = pd.cut(data['Battery_Level'], bins)

frequencies = data['Battery_Bin'].value_counts().sort_index()

bin_midpoints = [(interval.left + interval.right) / 2 for interval in frequencies.index]

bin_midpoints = np.array(bin_midpoints)
frequencies = np.array(frequencies)

N = frequencies.sum()
mean_battery_fd = np.sum(frequencies * bin_midpoints) / N
variance_battery_fd = np.sum(frequencies * (bin_midpoints - mean_battery_fd) ** 2) /( N-1)

print(f"--- Battery_Bin ---")
print(f"Mean (via freq dist): {mean_battery_fd:.2f}")
print(f"Variance (via freq dist): {variance_battery_fd:.2f}")
print(f"True Mean: {mean_battery_level:.2f}")
print(f"True Variance: {variance_battery_level:.2f}")
print(f"Difference in Mean: {abs(mean_battery_fd - mean_battery_level):.2f}")
print(f"Difference in Variance: {abs(variance_battery_fd - variance_battery_level):.2f}\n")

def frequency_distribution_stats(data, column, bins=5):
    print(f"\n--- {column} ---")

    col_min, col_max = data[column].min(), data[column].max()
    bin_edges = np.linspace(col_min, col_max, bins + 1)

    binned = pd.cut(data[column], bins=bin_edges)

    freq = binned.value_counts().sort_index()

    midpoints = np.array([(interval.left + interval.right) / 2 for interval in freq.index])
    frequencies = np.array(freq.values)
    N = frequencies.sum()

    mean_fd = np.sum(frequencies * midpoints) / N
    var_fd = np.sum(frequencies * (midpoints - mean_fd) ** 2) / (N - 1)

    true_mean = meanvalues(data[column])
    true_var = variancevalues(data[column])

    print(f"Mean (freq dist): {mean_fd:.2f}")
    print(f"Variance (freq dist): {var_fd:.2f}")
    print(f"True Mean: {true_mean:.2f}")
    print(f"True Variance: {true_var:.2f}")
    print(f"Difference in Mean: {abs(mean_fd - true_mean):.2f}")
    print(f"Difference in Variance: {abs(var_fd - true_var):.2f}")

    return mean_fd, var_fd

numerical_cols = [
    'Battery_Level', 'Velocity', 'Wind_Speed',
    'Temperature', 'Task_Completion_Time',
    'Coverage_Efficiency', 'Obstacle_Distance',
    'Communication_Signal_Strength'
]

for col in numerical_cols:
    frequency_distribution_stats(data.copy(), col, bins=5)

"""# Confidence Interval"""

from math import sqrt
from sklearn.model_selection import train_test_split
from scipy.stats import norm, chi2
from scipy.stats import t

def confidence_interval(data, confidence_level=0.95):

  n = len(data) # sample size
  df = n - 1 # degrees of freedom
  mean = meanvalues(data) # sample mean
  std = sqrt(variancevalues(data)) # sample standard deviation

  # standard error
  se = std / sqrt(n)

  # critical value
  alpha = 1 - confidence_level # significance level
  t_value = t.ppf((1-alpha/2),df)

  margin_of_error = t_value * se

  lower_bound = mean - margin_of_error
  upper_bound = mean + margin_of_error

  return lower_bound, upper_bound

def validate(data, confidence=0.95, coverage=0.95):
    # Split the data
    train, test = train_test_split(data, test_size=0.2)

    # Recalculate mean, std, n on training data
    mean_train = meanvalues(train)
    std_train = sqrt(variancevalues(train))
    n_train = len(train)

    # Calculate tolerance factor k
    z = norm.ppf((1 + coverage) / 2)
    k = z * sqrt((n_train - 1) / chi2.ppf(confidence, df=n_train - 1))

    # Tolerance interval from training data
    lower = mean_train - k * std_train
    upper = mean_train + k * std_train

    # Validate with test data
    within = sum(lower <= x <= upper for x in test)
    total = len(test)
    print(f"{within} out of {total} test values are within the tolerance interval.")
    print(f"Tolerance Interval: [{lower:.2f}, {upper:.2f}]")

print("(95% Confidence Intervals):")
for feature in ['Battery_Level', 'Velocity', 'Wind_Speed', 'Temperature',
                'Task_Completion_Time', 'Coverage_Efficiency', 'Obstacle_Distance']:
    lower, upper = confidence_interval(data[feature])
    print(f"{feature.replace('_', ' ')}: ({lower:.2f}, {upper:.2f})")

print("\nTolerance Limit (Validation Results):")
for feature in ['Battery_Level', 'Velocity', 'Wind_Speed', 'Temperature',
                'Task_Completion_Time', 'Coverage_Efficiency', 'Obstacle_Distance']:
    print(f"{feature} : ")
    validate(data[feature])
    print("")

"""#Hypothesis Testing

Null Hypothesis: Surveillance missions consume more battery on average compared to other UAV task types.

Alternate Hypothesis: Surveillance missions do not consume more battery on average compared to other UAV task types — i.e., their battery consumption is the same or less than other tasks.

1. Group by Task_Type and calculate average battery consumption
"""

battery_by_task = data.groupby('Task_Type')['Battery_Level'].mean()
print(battery_by_task)

"""2. Compare Surveillance with other task types using a statistical test"""

from scipy.stats import ttest_ind

surveillance = data[data['Task_Type'] == 'Surveillance']['Battery_Level']
others = data[data['Task_Type'] != 'Surveillance']['Battery_Level']

t_stat, p_value = ttest_ind(surveillance, others, equal_var=False)
print("T-statistic:", t_stat)
print("P-value:", p_value)

"""Since the p-value (0.204) > 0.05, null hypothesis is not rejected due to not enough evidence

Insight: This finding suggests that battery consumption is fairly consistent across different UAV tasks, or at least not significantly different for surveillance. That’s valuable because it helps in standardizing battery expectations across mission types.

#Further Analysis

##1. What’s the usual velocity range for surveillance missions?
"""

data[data['Task_Type'] == 'Surveillance']['Velocity'].describe()

surveillance_velocity_stats = data[data['Task_Type'] == 'Surveillance']['Velocity'].describe()
print(surveillance_velocity_stats)

plt.figure(figsize=(8, 5))
sns.boxplot(x='Task_Type', y='Velocity', data=data, color ='pink')
plt.title('Velocity Distribution by UAV Task Type')
plt.xticks(rotation=15)
plt.grid(True)
plt.show()

sns.histplot(data=data, x='Velocity', hue='Task_Type', kde=True, element='step', color ='purple')
plt.title('Velocity Distribution by Task Type')
plt.show()

"""##2. Are UAVs likely to succeed more under certain weather conditions?"""

data.groupby(pd.cut(data['Wind_Speed'], bins=5))['Task_Success'].mean()
data.groupby(pd.cut(data['Temperature'], bins=5))['Task_Success'].mean()

"""UAV success rates are highest in moderate temperatures (10–30°C), peaking around 10–20°C. In contrast, colder (< 0°C) and hotter (> 30°C) environments show a slight drop in success, suggesting that extreme temperatures may slightly hinder UAV performance."""

temp_bins = ['<0°C', '0-10°C', '10-20°C', '20-30°C', '>30°C']
success_rates = [0.6201, 0.6124, 0.6371, 0.6358, 0.6021]

plt.plot(temp_bins, success_rates, marker='o', color='purple')
plt.title('UAV Success Rate vs Temperature')
plt.xlabel('Temperature Range')
plt.ylabel('Success Rate')
plt.ylim(0.59, 0.65)
plt.grid(True)
plt.show()

"""##3.How confident can we be in our estimates about performance metrics?"""

data.groupby('Task_Type')['Battery_Level'].std()
data.groupby('Task_Type')['Velocity'].var()

"""The typical UAV velocity lies between 18–38 m/s, based on the interquartile range. However, Surveillance missions show a much higher average velocity of ~128.86 m/s, suggesting that these missions prioritize coverage speed over precision."""

import scipy.stats as stats
import numpy as np

# Sample size, mean, and std deviation
n = data['Velocity'].count()
mean = data['Velocity'].mean()
std = data['Velocity'].std()

# 95% Confidence Interval
conf_interval = stats.t.interval(
    confidence=0.95,
    df=n-1,
    loc=mean,
    scale=std / np.sqrt(n)
)

print(f"Mean Velocity: {mean:.2f} m/s")
print(f"95% Confidence Interval: {conf_interval}")

"""The mean UAV velocity is estimated at 29.31 m/s, with a 95% confidence interval of [28.60, 30.02] m/s, suggesting a high level of confidence in this performance metric.

1. What’s the usual velocity range for surveillance missions?
The typical velocity range for Surveillance tasks is between 18 m/s to 38 m/s, with an average velocity of 128.86 m/s.

Surveillance requires relatively high-speed operations to cover large areas or track fast-moving objects, which is reflected in the higher velocity compared to other task types like Recon or Object Detection.

2. Are UAVs likely to succeed more under certain weather conditions?
The temperature impacts the UAV success rate, with the highest success rates observed in 10-20°C (63.71%), followed by 20-30°C (63.58%).

Extreme cold or hot temperatures (below 0°C or above 30°C) lead to lower success rates, indicating that UAVs might struggle in harsh weather conditions.

This can be attributed to the UAV’s mechanical and battery limitations in extreme temperatures.

3. How confident can we be in our estimates about performance metrics?
The mean velocity of UAVs is estimated at 29.31 m/s, with a 95% confidence interval of [28.60, 30.02] m/s. This tight range suggests a high degree of confidence in this estimate.

The confidence interval (CI) suggests that variations in velocity due to operational conditions (weather, terrain, task) are minimal, providing reliability in the estimates.

Summary of Key Insights:

Velocity Range for most missions lies between 18 m/s to 38 m/s, with Surveillance tasks having higher speeds.

Temperature influences success rates, with moderate temperatures (10-30°C) offering optimal conditions for UAV operations.

The confidence in velocity estimates suggests a reliable and consistent performance metric.
"""